# 附录 A：Rust 术语表 (Glossary of Rust Terms)

本附录旨在提供一个 Rust 语言及其生态系统中常见术语的快速参考。这些术语在本书中以及更广泛的 Rust 社区讨论中经常出现。

---

**A**

*   **ABI (Application Binary Interface - 应用程序二进制接口)**
    *   描述了程序模块（如函数、库）之间在机器码层面的接口约定，包括调用约定、数据类型表示、名称修饰等。FFI (外部函数接口) 依赖于匹配的 ABI (例如 `extern "C"` 指定使用 C 语言的 ABI)。
*   **Abstract Data Type (ADT - 抽象数据类型)**
    *   一种数据类型，其行为由一组操作定义，而不暴露其内部表示。Rust 中的结构体和枚举可以用来创建 ADT，通过 `pub` 控制字段和方法的可见性来封装内部细节。
*   **Allocation (内存分配)**
    *   程序向操作系统请求内存空间的过程。通常分为栈分配 (stack allocation) 和堆分配 (heap allocation)。
*   **`Arc<T>` (Atomically Referenced Counted)**
    *   一个线程安全的引用计数智能指针。允许多个所有者在不同线程间共享对同一数据的只读访问。当最后一个 `Arc` 指针被销毁时，数据才会被清理。详见第9章。
*   **Argument (参数)**
    *   传递给函数或宏的值。
*   **Array (数组)**
    *   一种固定大小的、包含相同类型元素的集合，存储在栈上（如果大小和类型允许）。例如 `[i32; 5]`。详见第2章。
*   **`async/await`**
    *   Rust 中用于编写异步代码的关键字。`async fn` 定义一个返回 Future 的异步函数，`.await` 用于暂停异步函数的执行直到其等待的 Future 完成。详见第10章。
*   **Attribute (属性)**
    *   附加到 Rust 代码项（如函数、结构体、模块）的元数据。以 `#[...]` (外部属性) 或 `#![...]` (内部属性，用于模块或 crate) 的形式出现。例如 `#[derive(Debug)]`, `#[test]`, `#[cfg(target_os = "linux")]`。
*   **Associated Function (关联函数)**
    *   在 `impl` 块中定义，但其第一个参数不是 `self`, `&self`, 或 `&mut self` 的函数。它与类型关联，但不直接操作该类型的实例。通常用作构造器 (如 `String::new()`)，通过 `TypeName::function_name()` 调用。详见第5章。
*   **Associated Type (关联类型)**
    *   Trait 中的一个占位符类型，允许 trait 定义方法签名时使用与实现该 trait 的类型相关的特定类型。与泛型参数不同，每个实现类型只能为关联类型指定一个具体类型。

**B**

*   **Binding (绑定)**
    *   将一个名称（变量名）与一个值关联起来的过程，通过 `let` 关键字实现。例如 `let x = 5;`。
*   **Binary Crate (二进制 Crate)**
    *   一种可以被编译成可执行程序的 crate。通常有一个 `src/main.rs` 文件作为入口点。
*   **Block (代码块)**
    *   由花括号 `{}` 包围的一组语句和/或一个表达式。代码块本身也是一个表达式，其值是块中最后一个表达式的值（如果该表达式没有以分号结尾）。
*   **Borrow Checker (借用检查器)**
    *   Rust 编译器的一部分，负责在编译时静态分析代码，以确保所有引用（借用）都是有效的，并且没有违反借用规则（例如，没有悬垂引用，没有同时存在可变和不可变引用指向同一数据等）。这是 Rust 内存安全的核心。详见第4章。
*   **Borrowing (借用)**
    *   创建一个指向某个值的引用 (`&T` 或 `&mut T`) 而不获取其所有权的过程。详见第4章。
*   **`Box<T>`**
    *   一个简单的智能指针，用于在堆上分配数据 `T`。`Box<T>` 拥有其指向的数据。详见第9章。

**C**

*   **Cargo**
    *   Rust 的官方构建系统和包管理器。负责编译代码、管理依赖项、运行测试、发布包到 crates.io 等。详见第1章和第12章。
*   **`Cargo.toml`**
    *   Cargo 项目的清单文件 (manifest file)，采用 TOML 格式。定义了项目的元数据、依赖项、特性等。详见第12章。
*   **`Cargo.lock`**
    *   一个自动生成的文件，记录了项目构建时所有依赖项的确切版本。用于确保可重现构建。详见第12章。
*   **Channel (通道)**
    *   一种并发原语，用于在线程或异步任务之间进行消息传递。Rust 标准库的 `std::sync::mpsc` 模块提供了多生产者单消费者 (MPSC) 通道。详见第10章。
*   **`char`**
    *   Rust 的字符类型，表示一个 Unicode 标量值。占用 4 个字节。详见第2章。
*   **Closure (闭包)**
    *   一种可以捕获其环境（定义时所在作用域的变量）的匿名函数。闭包可以存储在变量中、作为参数传递或从函数返回。根据其捕获方式，实现 `Fn`、`FnMut` 或 `FnOnce` trait。详见第13章。
*   **`Clone` Trait**
    *   一个用于显式创建类型深拷贝的 trait。实现 `Clone` 的类型有一个 `clone(&self) -> Self` 方法。
*   **`Copy` Trait**
    *   一个特殊的标记 trait。如果一个类型实现了 `Copy`，那么它的值在赋值、传参或从函数返回时会进行简单的位拷贝，而不是移动所有权。实现了 `Drop` 的类型不能实现 `Copy`。通常用于完全存储在栈上的简单类型。详见第4章。
*   **Collection (集合)**
    *   一种可以存储多个值的数据结构。Rust 标准库提供了几种常用的集合类型，如 `Vec<T>` (向量), `String` (字符串), `HashMap<K, V>` (哈希映射)。详见第6章。
*   **Compiler (编译器)**
    *   将人类可读的源代码（如 Rust 代码）转换为机器可执行代码的程序。Rust 的编译器是 `rustc`。
*   **Concurrency (并发)**
    *   指程序的多个部分能够独立执行，可能以交错的方式在单个处理器上运行，或者并行地在多个处理器上运行。详见第10章。
*   **Constant (常量)**
    *   使用 `const` 关键字声明的不可变值。常量必须在编译时确定其值，并且必须显式注明类型。例如 `const MAX_SIZE: usize = 100;`。详见第2章。
*   **Consuming Adapter (消耗适配器)**
    *   迭代器的一种方法，它会消耗（迭代完）迭代器并产生某种结果。例如 `collect()`, `sum()`, `for_each()`。
*   **Crate**
    *   Rust 代码的编译单元。一个 crate 可以是一个库 (library crate) 或一个可执行程序 (binary crate)。Crate 可以包含多个模块。详见第12章。
*   **Crates.io**
    *   Rust 社区的官方 crate 仓库，用于发布和查找开源的 Rust 库。详见第12章。

**D**

*   **Dangling Reference/Pointer (悬垂引用/指针)**
    *   一个指向已被释放或不再有效的内存位置的引用或指针。访问悬垂引用/指针会导致未定义行为。Rust 的借用检查器旨在防止悬垂引用。详见第4章和第8章。
*   **Data Race (数据竞争)**
    *   一种并发 bug，发生在以下情况同时满足时：
        1.  两个或多个线程并发地访问同一块内存位置。
        2.  其中至少有一个访问是写操作。
        3.  访问没有使用任何同步机制（如锁）来协调。
    *   Rust 的所有权和类型系统（特别是 `Send` 和 `Sync` trait）旨在编译时防止数据竞争。详见第10章。
*   **Deadlock (死锁)**
    *   一种并发状态，其中两个或多个线程相互等待对方释放资源（如锁），导致所有相关线程都无法继续执行。详见第10章。
*   **Declarative Macro (声明宏)**
    *   使用 `macro_rules!` 定义的宏。通过模式匹配和代码替换工作。详见第13章。
*   **Default Trait**
    *   一个用于提供类型“默认”值的 trait。实现 `Default` 的类型有一个 `default() -> Self` 方法。例如 `String::default()` 返回一个空字符串。
*   **Dependency (依赖项)**
    *   一个项目（crate）所依赖的其他 crate。在 `Cargo.toml` 中声明。
*   **`Deref` Trait (Dereference)**
    *   允许自定义解引用运算符 `*` 的行为。通常由智能指针类型实现，使其可以像常规引用一样被访问。它还启用了 Deref 强制转换。详见第9章。
*   **Deref Coercion (Deref 强制转换)**
    *   一种方便的 Rust 特性。如果类型 `T` 实现了 `Deref<Target=U>`，那么 `&T` (对 `T` 的引用) 可以在需要 `&U` 的地方被自动转换为 `&U`。这可以发生多次（例如 `&MyBox<String>` -> `&String` -> `&str`）。
*   **Destructuring (解构)**
    *   一种从元组、结构体或枚举中提取其部分或全部分值的语法。例如 `let (x, y) = (1, 2);` 或 `if let Some(value) = option_value { ... }`。
*   **`Drop` Trait**
    *   允许自定义当一个值离开作用域时执行的清理代码（例如，释放资源）。实现了 `Drop` 的类型有一个 `drop(&mut self)` 方法，由编译器自动调用。详见第9章。
*   **Dynamic Dispatch (动态分发)**
    *   一种在运行时确定调用哪个具体方法实现的技术。在 Rust 中，Trait 对象 (`&dyn MyTrait`) 使用动态分发。与静态分发相比，通常有轻微的运行时开销（如虚表查找）。详见第8章。

**E**

*   **Edition (版本纪元)**
    *   Rust 的一种机制，允许语言在不破坏现有代码的情况下引入新的、可能不兼容的特性。每个 crate 在其 `Cargo.toml` 中声明它所使用的 edition (如 `"2015"`, `"2018"`, `"2021"`)。编译器会根据声明的 edition 来解释代码。详见第12章。
*   **Enum (Enumeration - 枚举)**
    *   一种允许你定义一个可以是一组预定义变体 (variants) 之一的类型。每个变体可以有关联数据。例如 `Option<T>` (有 `Some(T)` 和 `None` 变体) 和 `Result<T, E>` (有 `Ok(T)` 和 `Err(E)` 变体)。详见第5章。
*   **Error Handling (错误处理)**
    *   程序中处理错误和异常情况的机制。Rust 主要通过 `panic!` (不可恢复错误) 和 `Result<T, E>` (可恢复错误) 来处理错误。详见第7章。
*   **Expression (表达式)**
    *   Rust 代码中会计算并产生一个值的部分。例如 `5 + 6`，函数调用，宏调用，`if` 语句，代码块 `{}` 等。详见第2章。
*   **`extern`**
    *   关键字，用于声明外部函数、变量或块。常用于 FFI，例如 `extern "C" { ... }` 声明 C ABI 的外部项。

**F**

*   **Feature (特性)**
    *   Cargo 的一种机制，允许包的作者定义可选的功能或依赖项，用户可以选择性地启用它们。通过 `#[cfg(feature = "my_feature")]` 进行条件编译。详见第12章。
*   **FFI (Foreign Function Interface - 外部函数接口)**
    *   允许一种编程语言的代码调用另一种编程语言的代码的机制。Rust 的 FFI 主要用于与 C 语言库交互。详见第13章。
*   **Field (字段)**
    *   结构体或枚举变体中命名的成员数据。
*   **`Fn`, `FnMut`, `FnOnce` Traits**
    *   闭包根据其捕获和使用环境的方式自动实现的 trait。`FnOnce` (消耗所有权，最多调用一次)，`FnMut` (可变借用，可多次调用)，`Fn` (不可变借用，可多次调用)。详见第13章。
*   **Function (函数)**
    *   一段命名的、可执行的代码块，可以接收参数并返回值。使用 `fn` 关键字定义。
*   **Future**
    *   在异步编程中，一个代表尚未完成的计算的值。`async fn` 返回一个 Future。通过 `.await` 来等待 Future 完成。详见第10章。

**G**

*   **Generic (泛型)**
    *   允许编写能够处理多种具体类型的代码（函数、结构体、枚举、方法）的特性，通过使用类型参数 (如 `<T>`) 来实现抽象。详见第8章。
*   **Grapheme Cluster (字形簇)**
    *   用户感知到的单个“字符”。在 Unicode 中，一个字形簇可能由多个 Unicode 标量值 (Rust 的 `char`) 组成（例如，一个基础字符加上一个或多个组合标记）。标准库不直接处理字形簇，需要外部 crate (如 `unicode-segmentation`)。

**H**

*   **Hash Map (`HashMap<K, V>`)**
    *   一种存储键值对的集合类型，通过哈希函数快速查找值。键必须实现 `Eq` 和 `Hash` trait。详见第6章。
*   **Heap (堆)**
    *   程序运行时可用于动态分配内存的一块内存区域。堆上分配的数据大小可以在编译时未知或在运行时改变。`Box<T>`, `String`, `Vec<T>` 的数据通常存储在堆上。详见第4章。

**I**

*   **Idiomatic (地道的)**
    *   指符合特定编程语言的通常风格、约定和最佳实践的代码。
*   **`impl` (Implementation - 实现)**
    *   关键字，用于为类型（结构体、枚举）实现方法或为类型实现 trait。例如 `impl MyStruct { ... }` 或 `impl MyTrait for MyStruct { ... }`。
*   **Immutable (不可变的)**
    *   指值在创建后不能被修改。Rust 中的变量默认是不可变的，除非使用 `mut` 关键字声明。
*   **Inference (推断)**
    *   编译器根据上下文自动确定类型或生命周期的过程。例如，`let x = 5;` 编译器会推断 `x` 的类型是 `i32`。
*   **Interior Mutability (内部可变性)**
    *   一种设计模式，允许在持有对数据的不可变引用时也能修改数据。通常通过 `Cell<T>` 或 `RefCell<T>` (单线程) 或 `Mutex<T>`/`RwLock<T>` (多线程) 等类型实现，它们在运行时或通过同步机制强制执行借用规则。详见第9章。
*   **Interface (接口)**
    *   在面向对象编程中，定义了一组类型必须实现的方法。Rust 中的 Trait 扮演了类似接口的角色。
*   **Iterator (迭代器)**
    *   一种结构，允许你按顺序访问一个序列中的元素。Rust 的迭代器是惰性的，并提供了许多适配器方法（如 `map`, `filter`, `fold`）来处理数据。核心是 `Iterator` trait 及其 `next()` 方法。详见第13章。

**J**

*   **JSON (JavaScript Object Notation)**
    *   一种轻量级的数据交换格式。Rust 中常使用 `serde` 和 `serde_json` crate 来进行 JSON 的序列化和反序列化。
*   **Join Handle (`std::thread::JoinHandle`)**
    *   `thread::spawn` 返回的类型，代表一个派生的线程。调用其 `join()` 方法会阻塞当前线程，直到派生线程执行完毕。

**L**

*   **Lazy Evaluation (惰性求值)**
    *   一种求值策略，表达式的值只有在真正需要时才被计算。Rust 的迭代器是惰性的。
*   **`let`**
    *   用于声明变量并绑定值的关键字。
*   **Library Crate (库 Crate)**
    *   一种不包含 `main` 函数的 crate，它提供可供其他程序或库使用的代码和功能。通常有一个 `src/lib.rs` 文件作为入口点。
*   **Lifetime (生命周期)**
    *   Rust 用来确保所有引用总是有效的一种机制。生命周期描述了引用保持有效的范围（作用域）。通过生命周期注解 (`'a`) 来帮助编译器进行借用检查。详见第8章。
*   **Lifetime Elision Rules (生命周期省略规则)**
    *   编译器在许多常见情况下自动推断生命周期的规则，使得程序员不必总是显式注解生命周期。详见第8章。
*   **Linker (链接器)**
    *   一个在编译过程的最后阶段运行的程序，它将编译器生成的多个目标文件和库组合成一个单一的可执行文件或库。
*   **Lint (Linter)**
    *   一种静态代码分析工具，用于标记程序代码中可疑的、非结构化的（可能导致错误的）或不符合风格约定的部分。Rust 的 `clippy` 就是一个 linter。
*   **Literal (字面量)**
    *   源代码中直接表示固定值的表示法。例如 `5` (整数), `"hello"` (字符串), `true` (布尔)。
*   **Loop (循环)**
    *   一种控制流结构，允许重复执行一段代码。Rust 有 `loop`, `while`, `for` 三种循环。详见第3章。

**M**

*   **`macro_rules!`**
    *   用于定义声明宏的关键字。
*   **Macro (宏)**
    *   一种元编程机制，允许编写能生成其他 Rust 代码的 Rust 代码。分为声明宏和过程宏。详见第13章。
*   **`main` Function (主函数)**
    *   二进制 crate 的入口点函数。
*   **Manifest File (清单文件)**
    *   指 `Cargo.toml` 文件，包含了项目的元数据和配置。
*   **`match`**
    *   Rust 中强大的控制流运算符，允许将一个值与一系列模式进行比较，并根据匹配的模式执行相应的代码。`match` 必须是穷尽的。详见第3章和第5章。
*   **Memory Safety (内存安全)**
    *   指程序在运行时不会发生诸如空指针解引用、悬垂指针、缓冲区溢出、数据竞争等内存相关的错误。Rust 通过所有权、借用和生命周期系统在编译时保证内存安全（在安全 Rust 代码中）。
*   **Metaprogramming (元编程)**
    *   编写能够操作或生成其他程序的程序的技术。Rust 中的宏就是一种元编程。
*   **Method (方法)**
    *   在结构体、枚举或 trait 的上下文中定义的函数。其第一个参数通常是 `self`, `&self`, 或 `&mut self`，代表调用该方法的实例。详见第5章。
*   **Module (模块)**
    *   Rust 中组织代码、控制作用域和路径的方式。使用 `mod` 关键字定义。
*   **Monomorphization (单态化)**
    *   编译器在编译时将泛型代码转换为针对每个具体使用类型的特定代码的过程。这是 Rust 实现泛型零成本抽象的关键。详见第8章。
*   **Move (移动)**
    *   Rust 所有权系统中的一个概念。当拥有堆上数据（如 `String`, `Vec<T>`）的值被赋给另一个变量、作为参数传递或从函数返回时，其所有权会转移（移动），原始变量不再有效。详见第4章。
*   **`mpsc` (Multiple Producer, Single Consumer)**
    *   `std::sync::mpsc` 模块提供了这种类型的通道，允许多个发送端向单个接收端发送消息。
*   **`mut` (Mutable - 可变的)**
    *   关键字，用于声明一个变量或引用是可变的，允许其绑定的值被修改。
*   **`Mutex<T>` (Mutual Exclusion - 互斥锁)**
    *   一种同步原语，用于保护共享数据，确保在任何时候只有一个线程可以访问该数据。详见第10章。

**N**

*   **Newtype Pattern (新类型模式)**
    *   通过将现有类型包装在单元结构体或单字段元组结构体中来创建语义上不同的新类型，以增强类型安全。详见第14章。
*   **`None`**
    *   `Option<T>` 枚举的一个变体，表示没有值。
*   **Null Pointer (空指针)**
    *   一个不指向任何有效内存地址的指针。Rust 通过 `Option<T>` 来避免传统意义上的空指针及其相关问题。

**O**

*   **Object Safety (对象安全)**
    *   指一个 trait 是否可以用来创建 trait 对象 (`dyn Trait`)。某些 trait（例如，方法返回 `Self` 或有泛型参数的）不是对象安全的。详见第8章。
*   **`Option<T>`**
    *   标准库中的一个泛型枚举，用于表示一个值可能是某个 `T` 类型的值 (`Some(T)`)，也可能没有值 (`None`)。Rust 用它来处理可选值和避免空指针。详见第5章。
*   **Orphan Rule (孤儿规则)**
    *   Rust 的一条规则，规定要为类型 `T` 实现 trait `Tr`，`T` 或 `Tr` 中至少有一个必须是在当前 crate 中定义的。这防止了对外部类型随意实现外部 trait。详见第8章。
*   **Ownership (所有权)**
    *   Rust 的核心特性，是一套管理内存的规则，由编译器在编译时检查。每个值有唯一所有者，所有者离开作用域则值被丢弃。详见第4章。

**P**

*   **Package (包)**
    *   一个或多个 crate 的集合，提供一组功能。一个包包含一个 `Cargo.toml` 文件，描述了如何构建这些 crate。
*   **`panic!`**
    *   一个宏，用于使当前线程立即停止执行并开始展开调用栈（或终止程序，取决于配置），通常在遇到不可恢复的错误或程序 bug 时使用。详见第7章。
*   **Parallelism (并行)**
    *   指程序的不同部分同时在多个物理处理器核心上执行。并发是并行的前提。
*   **Parameter (参数)**
    *   函数或宏定义中声明的变量，用于接收调用时传入的值。
*   **Path (路径)**
    *   在 Rust 中，用于命名项（如函数、结构体、模块）的方式。例如 `std::collections::HashMap`。
*   **Pattern (模式)**
    *   Rust 中一种特殊的语法，用于匹配值的结构。用在 `match` 表达式、`if let`、`while let`、`let` 语句和函数参数中。
*   **Pointer (指针)**
    *   一个存储内存地址的变量。Rust 中有引用 (`&T`, `&mut T`)、裸指针 (`*const T`, `*mut T`) 和智能指针 (`Box<T>`, `Rc<T>` 等)。
*   **Prelude (预导入)**
    *   Rust 标准库中的一小部分常用项（如 `Option`, `Result`, `Vec`, `String`, `println!` 等），它们被自动导入到每个 Rust 程序的模块作用域中，无需显式 `use`。
*   **Procedural Macro (过程宏)**
    *   一种更强大的宏，接收 Rust 代码的 `TokenStream` 作为输入，对其进行操作，并返回新的 `TokenStream`。分为自定义 `derive` 宏、属性宏和函数宏。详见第13章。
*   **Process (进程)**
    *   操作系统中一个正在执行的程序的实例。每个进程有其独立的内存空间。
*   **Profile (构建配置文件)**
    *   Cargo 中用于定义不同构建模式（如 `dev` 开发模式, `release` 发布模式）的编译选项（如优化级别、调试信息）的配置。在 `Cargo.toml` 中设置。
*   **`pub` (Public - 公开的)**
    *   关键字，用于使项（如函数、结构体、模块）在其定义的模块外部可见。

**Q**

*   **`quote` Crate**
    *   一个流行的辅助 crate，常与 `syn` crate 一起用于编写过程宏，它提供了方便的方式来生成 Rust 代码的 `TokenStream`。

**R**

*   **RAII (Resource Acquisition Is Initialization - 资源获取即初始化)**
    *   一种编程习语，将资源的生命周期与对象的生命周期绑定。资源在对象创建时获取，在对象销毁时（通过 `Drop` trait）自动释放。详见第9章和第14章。
*   **Race Condition (竞争条件)**
    *   一种并发 bug，当程序的行为取决于多个线程或进程对共享资源的非同步访问顺序时发生。数据竞争是竞争条件的一种。
*   **Raw Pointer (裸指针)**
    *   `*const T` (不可变) 和 `*mut T` (可变) 类型的指针。它们不具有 Rust 的安全保证（如自动解引用、生命周期检查、空指针检查）。操作裸指针通常需要在 `unsafe` 块中进行。
*   **`Rc<T>` (Reference Counted)**
    *   一个单线程的引用计数智能指针。允许多个所有者共享对同一数据的只读访问。详见第9章。
*   **`RefCell<T>`**
    *   一个提供内部可变性的智能指针，允许在运行时检查借用规则。用于单线程场景。详见第9章。
*   **Reference (引用)**
    *   一个指向内存中某个值的地址，但不拥有该值。Rust 中有不可变引用 (`&T`) 和可变引用 (`&mut T`)。引用总是有效的（由借用检查器保证）。
*   **Reference Counting (引用计数)**
    *   一种内存管理技术，通过跟踪指向某个数据块的引用数量，当引用数量变为零时自动回收该数据块。`Rc<T>` 和 `Arc<T>` 使用引用计数。
*   **`Result<T, E>`**
    *   标准库中的一个泛型枚举，用于处理可能失败的操作。有两个变体：`Ok(T)` (成功，包含值 `T`) 和 `Err(E)` (失败，包含错误 `E`)。详见第7章。
*   **`return`**
    *   关键字，用于从函数中提前返回值。如果函数体的最后一个表达式没有分号，其值会自动作为函数的返回值（除非函数返回 `()`）。
*   **Rustdoc**
    *   Rust 的官方文档生成工具。它从源代码中的文档注释（`///`, `//!`）生成 HTML 文档。

**S**

*   **Safety (安全性)**
    *   在 Rust 中，通常指内存安全（没有悬垂指针、数据竞争等）和线程安全。
*   **Scope (作用域)**
    *   程序中一个项（如变量、引用）有效的区域。当项离开作用域时，它可能会被销毁或其引用失效。
*   **`self`, `&self`, `&mut self`**
    *   在 `impl` 块的方法中，用作第一个参数的特殊名称，分别代表：
        *   `self` (`Self` 类型): 方法获取实例的所有权。
        *   `&self` (`&Self` 类型): 方法不可变地借用实例。
        *   `&mut self` (`&mut Self` 类型): 方法可变地借用实例。
    *   `Self` (大写S) 是 `impl` 块所针对的类型的别名。
*   **Semantic Versioning (SemVer - 语义化版本控制)**
    *   一种版本号约定 (MAJOR.MINOR.PATCH)，用于传达版本间的兼容性。Cargo 依赖 SemVer 来管理依赖项版本。详见第12章。
*   **`Send` Trait**
    *   一个标记 trait，表明一个类型的值的所有权可以被安全地在线程间转移。详见第10章。
*   **Serialization (序列化)**
    *   将数据结构或对象状态转换为可以存储（例如，到文件或数据库）或传输（例如，通过网络）的格式（如 JSON, XML）的过程。`serde` 是 Rust 中流行的序列化/反序列化框架。
*   **Shadowing (遮蔽)**
    *   在同一作用域内使用 `let` 关键字声明一个与已存在变量同名的新变量。新变量会“遮蔽”旧变量。遮蔽允许改变变量的类型或可变性。详见第2章。
*   **Shared State (共享状态)**
    *   指多个线程或并发单元可以访问和修改的同一份数据。需要同步机制（如 `Mutex`）来保证安全访问。详见第10章。
*   **Slice (切片)**
    *   对集合中一段连续元素序列的引用，不持有所有权。例如 `&[T]` (数组/向量切片) 和 `&str` (字符串切片)。详见第4章。
*   **Smart Pointer (智能指针)**
    *   行为类似指针但具有额外功能（如所有权管理、自动资源释放）的数据结构。例如 `Box<T>`, `Rc<T>`, `RefCell<T>`。详见第9章。
*   **Stack (栈)**
    *   一块内存区域，用于存储函数调用信息、局部变量等。后进先出 (LIFO)。栈上分配的数据大小必须在编译时已知。详见第4章。
*   **Standard Library (Std - 标准库)**
    *   Rust 语言附带的一组核心库，提供了基本的数据类型、宏、函数和模块。
*   **Static Dispatch (静态分发)**
    *   一种在编译时确定调用哪个具体方法实现的技术。Rust 中的泛型（通过单态化）使用静态分发。通常比动态分发性能更好。详见第8章。
*   **`static`**
    *   关键字，用于声明静态变量，其生命周期是整个程序运行期间 (`'static`)。静态变量的值必须在编译时确定（对于 `static mut`，初始化值也需如此）。
*   **`'static` Lifetime (静态生命周期)**
    *   一个特殊的生命周期，表示引用可以在程序的整个持续时间内有效。字符串字面量具有 `'static` 生命周期。
*   **Statement (语句)**
    *   Rust 代码中执行某些操作但不返回值的指令。例如 `let x = 5;` (变量绑定语句)，函数定义。语句通常以分号结尾。详见第2章。
*   **`String`**
    *   标准库提供的可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。数据存储在堆上。详见第4章和第6章。
*   **`&str` (String Slice - 字符串切片)**
    *   对一段 UTF-8 字符串数据的不可变引用。字符串字面量是 `&str` 类型。详见第4章。
*   **Struct (Structure - 结构体)**
    *   一种自定义数据类型，允许将多个相关的值（字段）组合在一起并命名它们。详见第5章。
*   **`Sync` Trait**
    *   一个标记 trait，表明一个类型的不可变引用 `&T` 可以被安全地在线程间共享。详见第10章。
*   **`syn` Crate**
    *   一个流行的辅助 crate，用于解析 Rust 源代码字符串到抽象语法树 (AST)，常用于编写过程宏。

**T**

*   **Target (目标平台)**
    *   指编译 Rust 代码所针对的特定硬件架构和操作系统组合（例如 `x86_64-unknown-linux-gnu`）。
*   **Thread (线程)**
    *   程序中独立执行的最小指令序列。一个进程可以包含多个线程，它们可以并发或并行执行。详见第10章。
*   **Thread Pool (线程池)**
    *   一组预先创建的、可重用的工作线程，用于执行任务。有助于管理并发任务和控制资源消耗。
*   **TOML (Tom's Obvious, Minimal Language)**
    *   一种简单的配置文件格式，`Cargo.toml` 文件使用 TOML 格式。
*   **TokenStream**
    *   过程宏接收和返回的 Rust 代码的抽象表示（一系列 token）。
*   **Trait**
    *   Rust 中定义共享行为的方式，类似于其他语言中的接口。类型可以实现 trait 来表明它们具有某些功能。详见第8章。
*   **Trait Bound (Trait 约束)**
    *   对泛型类型参数施加的约束，要求该类型必须实现一个或多个指定的 trait。例如 `<T: Display + Debug>`。详见第8章。
*   **Trait Object (Trait 对象)**
    *   一种允许在运行时处理实现了特定 trait 的不同具体类型的值的方式。通常表示为 `&dyn MyTrait` 或 `Box<dyn MyTrait>`。使用动态分发。详见第8章。
*   **Tuple (元组)**
    *   一种固定大小的、可以包含不同类型元素的有序集合。例如 `(i32, f64, char)`。详见第2章。
*   **Tuple Struct (元组结构体)**
    *   一种有名称但其字段没有名称（只有类型）的结构体，行为类似元组。例如 `struct Color(u8, u8, u8);`。详见第5章。
*   **Type Alias (类型别名)**
    *   使用 `type` 关键字为现有类型创建一个新的名称（同义词）。类型别名不创建新类型。例如 `type Milliseconds = u64;`。
*   **Type Inference (类型推断)**
    *   编译器根据上下文自动确定变量或表达式的类型的能力。

**U**

*   **Unicode Scalar Value (Unicode 标量值)**
    *   Rust 的 `char` 类型表示的是一个 Unicode 标量值，它是一个从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 的数字。这包括了大多数抽象字符。
*   **Unit Type (`()`)**
    *   一个没有任何值的特殊类型，写作 `()`。不返回任何其他值的表达式或函数会隐式返回单元类型。
*   **Unit Struct (单元结构体)**
    *   没有任何字段的结构体。例如 `struct MyUnit;`。详见第5章。
*   **Unsafe Rust / `unsafe` Keyword (不安全 Rust / `unsafe` 关键字)**
    *   Rust 的一部分，允许执行编译器无法保证内存安全的操作（如解引用裸指针、调用 C 函数）。这些操作必须在 `unsafe { ... }` 块或 `unsafe fn` 中进行。详见第13章。
*   **Unwinding (栈展开)**
    *   当 `panic!` 发生时，Rust 默认的行为是回溯调用栈，并为遇到的每个函数的局部变量运行其 `drop` 方法（清理资源），然后线程退出。
*   **`unwrap()`**
    *   `Option<T>` 和 `Result<T, E>` 上的一个方法。如果值是 `Some(v)` 或 `Ok(v)`，则返回 `v`；如果是 `None` 或 `Err(e)`，则 `panic!`。应谨慎使用。
*   **UTF-8**
    *   一种变长的 Unicode 字符编码方案。Rust 的 `String` 和 `&str` 保证是有效的 UTF-8 编码。

**V**

*   **Variant (变体)**
    *   枚举类型中定义的可能值之一。例如，`Option<T>` 的变体是 `Some(T)` 和 `None`。
*   **`Vec<T>` (Vector - 向量)**
    *   标准库提供的可增长的、在堆上分配的、包含相同类型 `T` 元素的数组类型。详见第6章。

**W**

*   **`Weak<T>`**
    *   一种弱引用智能指针，与 `Rc<T>` (或 `Arc<T>`) 配合使用。`Weak<T>` 不增加强引用计数，因此不阻止其指向的数据被销毁。用于打破引用循环。需要调用 `upgrade()` 将其转换为 `Option<Rc<T>>` 来安全访问数据。详见第9章。
*   **`where` Clause (where 子句)**
    *   用于在泛型定义中（函数、结构体、impl 块等）更清晰地指定复杂的 trait bound。例如 `fn foo<T, U>(...) where T: Display, U: Debug { ... }`。

---

这个术语表并不详尽，但涵盖了 Rust 学习和开发过程中最常遇到的一些核心概念。随着你对 Rust 的深入，还会遇到更多特定领域的术语。

# 第 2 章：基本语法和数据类型

本章我们将学习 Rust 的基础构建块：变量、基本数据类型、函数、注释以及表达式和语句的区别。

## 2.1 变量和可变性

在 Rust 中，变量默认是**不可变的（immutable）**。这是 Rust 强调安全性和并发性的特性之一。

```rust
fn main() {
    let x = 5; // x 是不可变的
    println!("The value of x is: {}", x);
    // x = 6; // 这行会编译错误！Cannot assign twice to immutable variable `x`
    // println!("The value of x is: {}", x);
}
```

如果你希望一个变量是可变的，需要在变量名前使用 `mut` 关键字。

```rust
fn main() {
    let mut y = 10; // y 是可变的
    println!("The initial value of y is: {}", y);
    y = 20;
    println!("The new value of y is: {}", y);
}
```

**常量 (Constants)**

常量与不可变变量类似，但有一些区别：
1.  常量必须使用 `const` 关键字声明，而不是 `let`，并且必须显式注明值的类型。
2.  常量可以在任何作用域中声明，包括全局作用域。
3.  常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。
4.  常量在声明它们的整个程序生命周期内都有效。

命名约定：Rust 常量的命名约定是所有字母都使用大写，并使用下划线分隔单词，例如 `MAX_POINTS`。

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

fn main() {
    println!("Three hours in seconds: {}", THREE_HOURS_IN_SECONDS);
}
```

**遮蔽 (Shadowing)**

Rust 允许我们用相同的名字声明一个新的变量，新的变量会“遮蔽”之前声明的同名变量。这与将变量标记为 `mut` 不同，因为当我们再次使用 `let` 时，实际上是创建了一个全新的变量。我们可以改变值的类型，并复用同一个变量名。

```rust
fn main() {
    let z = 5;
    println!("The value of z is: {}", z); // 输出 5

    let z = z + 1; // z 被遮蔽，新的 z 是 6
    println!("The value of z is: {}", z); // 输出 6

    {
        let z = z * 2; // 内部作用域的 z 遮蔽了外部的 z，新的 z 是 12
        println!("The value of z in the inner scope is: {}", z); // 输出 12
    }

    println!("The value of z is: {}", z); // 输出 6，内部作用域的 z 已经结束

    let spaces = "   ";
    let spaces = spaces.len(); // 遮蔽，改变了类型从 &str 到 usize
    println!("Number of spaces: {}", spaces);
}
```
遮蔽的好处是，我们不必想出不同的名字，比如 `spaces_str` 和 `spaces_num`。

## 2.2 数据类型

Rust 是**静态类型**语言，这意味着它必须在编译时知道所有变量的类型。编译器通常可以根据值和我们如何使用它来推断出我们想要的类型 (type inference)。但是，如果多种类型皆有可能，比如从字符串转换为数字时，我们必须添加类型注解。

Rust 的数据类型分为两大类：**标量（Scalar）**和**复合（Compound）**。

### 2.2.1 标量类型

标量类型代表一个单独的值。Rust 有四种主要的标量类型：

1.  **整数 (Integers)**：
    *   有符号整数 (signed, 可以是负数): `i8`, `i16`, `i32`, `i64`, `i128`, `isize` (指针大小)
    *   无符号整数 (unsigned, 只能是正数): `u8`, `u16`, `u32`, `u64`, `u128`, `usize` (指针大小)
    *   `isize` 和 `usize` 的大小取决于程序运行的计算机体系结构：64 位架构上它们是 64 位，32 位架构上它们是 32 位。
    *   整数默认类型是 `i32`。
    *   整数溢出：在 debug 模式下，Rust 会 panic；在 release 模式下 (使用 `--release` 构建)，Rust 会进行“环绕” (two's complement wrapping)，例如 `u8` 类型的 `255 + 1` 会变成 `0`。

    ```rust
    let a: i32 = 98_222; // 使用下划线增加可读性
    let b = 0xff;    // 十六进制
    let c = 0o77;    // 八进制
    let d = 0b1111_0000; // 二进制
    let e = b'A';    // 字节 (u8 类型)
    let f: u8 = 255;
    // f = 256; // 这会编译错误，因为超出了 u8 的范围
    ```

2.  **浮点数 (Floating-Point Numbers)**：
    *   `f32`: 32 位单精度浮点数
    *   `f64`: 64 位双精度浮点数
    *   浮点数默认类型是 `f64`，因为它通常具有与 `f32` 差不多的速度，但精度更高。
    *   所有浮点类型都是有符号的。

    ```rust
    let x = 2.0; // f64 (默认)
    let y: f32 = 3.0; // f32
    ```

3.  **布尔类型 (Booleans)**：
    *   `bool`: 只能是 `true` 或 `false`。
    *   占用一个字节大小。

    ```rust
    let t = true;
    let f: bool = false; // 显式类型注解
    ```

4.  **字符类型 (Characters)**：
    *   `char`: 表示单个 Unicode 标量值。
    *   用单引号 `'` 表示。字符串用双引号 `"`。
    *   `char` 类型大小为 4 个字节 (因为它们代表 Unicode 标量值，而不仅仅是 ASCII)。

    ```rust
    let c = 'z';
    let z: char = 'ℤ'; // 显式类型注解
    let heart_eyed_cat = '😻';
    println!("Character: {}, {}, {}", c, z, heart_eyed_cat);
    ```

### 2.2.2 复合类型

复合类型可以将多个值组合成一个类型。Rust 有两种主要的内置复合类型：

1.  **元组 (Tuples)**：
    *   元组是将多个不同类型的值组合进一个复合类型的主要方式。
    *   元组长度固定：一旦声明，其长度不能伸缩。
    *   通过将逗号分隔的值写在圆括号内来创建元组。元组中的每个位置都有一个类型，元组中不同值的类型不必相同。

    ```rust
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // 解构元组 (Destructuring)
    let (x, y, z) = tup;
    println!("The value of y is: {}", y); // 输出 6.4

    // 通过索引访问元组成员 (从 0 开始)
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;
    println!("Access by index: {}, {}, {}", five_hundred, six_point_four, one);

    // 单元组 (Unit Tuple)
    // 一个没有任何值的元组 `()` 是一种特殊类型，只有一个值，也写作 `()`。
    // 表达式不返回任何其他值时，会隐式返回单元值。
    // 例如，`fn main()` 函数默认返回 `()`。
    let unit_tuple = ();
    ```

2.  **数组 (Arrays)**：
    *   数组中的每个元素必须具有**相同类型**。
    *   数组在 Rust 中长度是**固定**的。一旦声明，其大小不能改变。
    *   数组的值写成在方括号中的逗号分隔的列表。

    ```rust
    let a = [1, 2, 3, 4, 5]; // 类型会被推断为 [i32; 5]

    let months = ["January", "February", "March", "April", "May", "June", "July",
                  "August", "September", "October", "November", "December"];

    // 显式声明类型和长度
    let b: [i32; 5] = [1, 2, 3, 4, 5];

    // 初始化一个包含相同值的数组
    // [初始值; 数组长度]
    let c = [3; 5]; // 等同于 let c = [3, 3, 3, 3, 3];
    println!("Array c: {:?}", c); // 使用 {:?} 进行调试打印

    // 访问数组成员
    let first = a[0];
    let second = a[1];
    println!("First element of a: {}", first);

    // 索引越界访问
    // let element = a[10]; // 这会在运行时 panic！
    // Rust 会检查索引是否小于数组长度。如果索引超出了范围，Rust 会 panic (程序立即退出)。
    // 这是 Rust 内存安全原则的一部分。
    ```
    与数组不同，**Vector（向量）** 是标准库提供的一个类似集合的类型，它允许改变大小。如果不确定是使用数组还是 Vector，那么你可能应该使用 Vector。我们将在后续章节详细讨论 Vector。

## 2.3 注释

Rust 代码中的注释与 C/C++ 类似：
*   行注释：以 `//` 开始，直到行尾。
*   块注释：以 `/*` 开始，以 `*/` 结束，可以跨越多行。

```rust
// 这是一个行注释
// fn main() {
//     println!("Hello");
// }

/*
这是一个
多行
块注释
*/
fn main() {
    let lucky_number = 7; // 我感觉很幸运
}
```
注释通常用于解释代码的意图、复杂的逻辑或暂时禁用某些代码。

**文档注释 (Doc Comments)**：
Rust 还有一种特殊的注释用于生成文档，通常以 `///` (用于外部注释，注释其后的项) 或 `//!` (用于内部注释，注释其所在的项，如模块或 crate) 开头。它们支持 Markdown 语法。
```rust
/// 这是一个文档注释，描述了 add_one 函数。
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = chapter_02_basic_syntax_data_types::add_one(arg);
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```
使用 `cargo doc --open` 可以生成并查看项目的文档。

## 2.4 函数

函数在 Rust 代码中非常普遍。`main` 函数是程序的入口点。我们使用 `fn` 关键字来声明函数。

Rust 代码使用**蛇形命名法 (snake case)** 作为函数和变量名的常规风格，即所有字母都是小写并使用下划线分隔单词。

```rust
fn main() {
    println!("Hello from main!");
    another_function(); // 调用另一个函数
    function_with_parameters(5, 'h');
    let sum = add(10, 20);
    println!("Sum is: {}", sum);
}

// 定义一个简单的函数
fn another_function() {
    println!("Hello from another_function!");
}

// 定义带参数的函数
// 在函数签名中，必须声明每个参数的类型。
fn function_with_parameters(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}

// 带返回值的函数
// -> 符号后面指定返回值的类型。
// 在 Rust 中，返回值等同于函数体最后一个表达式的值。
// 你可以使用 `return` 关键字提前从函数中返回，但大多数函数隐式返回最后一个表达式。
fn add(a: i32, b: i32) -> i32 {
    a + b // 这是一个表达式，其结果将作为函数的返回值。注意末尾没有分号。
          // 如果加上分号，它就变成了一个语句，那么这个函数将返回 () (unit type)。
}
```

## 2.5 表达式与语句

Rust 是一门基于表达式的语言。理解表达式 (Expressions) 和语句 (Statements) 的区别非常重要。

*   **语句 (Statements)**：是执行某些操作但不返回值的指令。例如，`let x = 5;` 是一个语句。函数定义也是语句。
*   **表达式 (Expressions)**：会计算并产生一个值。例如，`5 + 6` 是一个表达式，它计算结果为 `11`。函数调用是一个表达式。宏调用是一个表达式。我们用 `{}` 创建的新作用域块也是一个表达式。

```rust
fn main() {
    // let x = (let y = 6); // 错误！`let y = 6` 是一个语句，不返回值。

    let y = {
        let x = 3;
        x + 1 // 这是一个表达式，这个块的值是 4。注意没有分号。
              // 如果这里有分号 `x + 1;`，那么这个块就变成了一个语句，其值为 `()`。
    };
    println!("The value of y is: {}", y); // 输出 4

    let result = demo_expression();
    println!("Result from demo_expression: {}", result);
}

fn demo_expression() -> i32 {
    // 这是一个表达式块
    {
        let a = 10;
        let b = 20;
        a + b // 返回 a + b 的结果
    }
}
```
**关键点**：
*   语句以分号结尾 (大部分情况下)。
*   表达式可以作为语句的一部分。
*   如果表达式末尾加上分号，它就变成了语句，其值变为 `()` (unit type)。这在函数返回值时尤其重要。

## 2.6 常见陷阱

1.  **类型推断的意外**：
    *   **陷阱**：有时编译器可能推断出一个你未预期的类型，特别是在处理数字字面量或复杂表达式时。例如，一个期望 `f32` 的地方，如果只写 `2.0`，它会被推断为 `f64`，可能导致类型不匹配错误。
    *   **避免**：在有歧义或重要的情况下，显式添加类型注解，如 `let guess: u32 = "42".parse().expect("Not a number!");` 或 `let my_float: f32 = 2.0;`。

2.  **整数溢出**：
    *   **陷阱**：在 release 模式下，整数溢出会进行环绕，这可能导致非预期的行为和逻辑错误，且不会 panic。例如 `let x: u8 = 255; let y = x + 1;` 在 release 模式下 `y` 会变成 `0`。
    *   **避免**：
        *   仔细考虑你的数据范围，选择合适的整数类型。
        *   使用标准库提供的 `checked_*`、`overflowing_*`、`saturating_*` 等方法进行算术运算，它们可以让你明确处理溢出情况。例如 `x.checked_add(1)` 会返回一个 `Option<u8>`。
        *   进行充分的测试，包括边界条件。

3.  **数组越界访问**：
    *   **陷阱**：尝试访问数组中不存在的索引会导致程序 panic。
    *   **避免**：
        *   确保索引总是在 `0` 到 `array.len() - 1` 的范围内。
        *   使用迭代器 (`for element in array.iter()`) 而不是手动索引访问。
        *   使用数组的 `.get(index)` 方法，它返回一个 `Option<&T>`，如果索引越界则返回 `None`，允许你优雅地处理越界情况。

4.  **函数返回值中表达式与语句的混淆**：
    *   **陷阱**：在期望返回值的函数中，如果最后一个表达式后面加了分号，它就变成了语句，函数会隐式返回 `()` (unit type)，导致类型不匹配错误。
        ```rust
        // 错误示例
        // fn five() -> i32 {
        //     5; // 加了分号，这个块的值是 ()，但函数期望返回 i32
        // }
        ```
    *   **避免**：确保函数体中用于返回值的最后一个表达式没有分号。如果需要提前返回，使用 `return` 关键字。

5.  **遮蔽与可变性的误解**：
    *   **陷阱**：新手可能混淆 `let x = ...; let x = ...;` (遮蔽) 和 `let mut x = ...; x = ...;` (可变性)。遮蔽是创建了一个全新的同名变量，可以改变类型；而可变性是修改同一个变量的值，类型不能改变。
    *   **避免**：明确两者的区别。遮蔽在转换类型或临时修改值时很有用，而可变性用于变量状态的生命周期内变化。

## 2.7 常见面试题

1.  **Q: 解释 Rust 中变量默认不可变性的原因和好处。**
    *   **A:**
        *   **原因**：Rust 设计的核心目标之一是安全，特别是并发安全。默认不可变性有助于实现这一目标。
        *   **好处**：
            *   **可读性和可理解性**：当你知道一个变量的值在其作用域内不会改变时，代码更容易推理。
            *   **安全性**：减少了意外修改数据的风险，特别是在复杂的代码或多线程环境中。如果数据是不可变的，你就不必担心其他代码会意外地改变它。
            *   **并发**：不可变数据可以安全地在多个线程之间共享，无需复杂的同步机制（如锁），因为不存在数据竞争的风险。
            *   **编译器优化**：编译器可以对不可变数据进行更多的优化。
        *   当你确实需要改变数据时，Rust 提供了 `mut` 关键字让你显式地选择可变性，这使得代码的意图更加明确。

2.  **Q: Rust 中的标量类型有哪些？`isize` 和 `usize` 有什么特殊之处？**
    *   **A:**
        *   Rust 的四种主要标量类型是：
            1.  **整数 (Integers)**：如 `i32`, `u64` 等。
            2.  **浮点数 (Floating-Point Numbers)**：`f32`, `f64`。
            3.  **布尔类型 (Booleans)**：`bool` (`true` 或 `false`)。
            4.  **字符类型 (Characters)**：`char` (Unicode 标量值)。
        *   `isize` 和 `usize` 的特殊之处在于它们的大小取决于程序运行的目标计算机体系结构：
            *   在 **64 位**架构上，它们是 **64 位**大小。
            *   在 **32 位**架构上，它们是 **32 位**大小。
            *   它们主要用于索引集合（如数组、向量），因为集合的长度可以用 `usize` 来表示，确保可以索引到集合中的每一个元素。`isize` 则用于表示指针的偏移量等。使用它们可以编写在不同架构上都能正确工作的代码。

3.  **Q: 什么是遮蔽 (Shadowing)？它与可变变量 (`mut`) 有什么区别？**
    *   **A:**
        *   **遮蔽 (Shadowing)**：是指在同一个作用域内，使用 `let` 关键字声明一个与已存在变量同名的新变量。这个新变量会“遮蔽”掉旧的变量。当使用该变量名时，指的是最新的那个变量。
            ```rust
            let x = 5;
            let x = x + 1; // 新的 x 遮蔽了旧的 x
            let x = "hello"; // 新的 x 再次遮蔽，并且改变了类型
            ```
        *   **可变变量 (`mut`)**：是指使用 `let mut` 声明一个变量后，可以在不改变其类型的前提下，修改该变量绑定的值。
            ```rust
            let mut y = 10;
            y = 20; // 修改 y 的值
            // y = "world"; // 错误！不能改变可变变量的类型
            ```
        *   **区别**：
            1.  **创建新变量 vs 修改旧变量**：遮蔽是创建了一个全新的变量，而 `mut` 是在原地修改同一个变量的值。
            2.  **类型改变**：遮蔽允许新变量拥有与旧变量不同的类型。而可变变量在修改值时必须保持其原始类型。
            3.  **不可变性**：通过遮蔽，旧变量在被遮蔽后仍然是不可变的（如果它最初是不可变的）。每次使用 `let` 都是一个新的绑定。

4.  **Q: Rust 中的元组 (Tuple) 和数组 (Array) 有什么主要区别？**
    *   **A:**
        *   **类型**：
            *   **元组**：可以包含多种不同类型的值。例如 `(i32, f64, char)`。
            *   **数组**：所有元素必须具有相同的类型。例如 `[i32; 5]`。
        *   **长度**：
            *   两者在 Rust 中都是固定长度的，一旦声明，长度不能改变。
        *   **访问方式**：
            *   **元组**：通过点号 `.` 和索引来访问元素，例如 `my_tuple.0`, `my_tuple.1`。
            *   **数组**：通过方括号 `[]` 和索引来访问元素，例如 `my_array[0]`, `my_array[1]`。
        *   **用途**：
            *   **元组**：通常用于将少量不同类型的值组合在一起，作为一个整体传递，例如函数返回多个值时。
            *   **数组**：通常用于存储一系列相同类型的元素，当你确定元素数量不会改变时。例如，存储一周每天的温度。
        *   **声明语法**：
            *   元组： `let tup: (i32, bool) = (500, true);`
            *   数组： `let arr: [i32; 3] = [1, 2, 3];`

5.  **Q: 解释 Rust 中表达式 (Expression) 和语句 (Statement) 的区别。为什么这个区别很重要？**
    *   **A:**
        *   **语句 (Statements)**：是执行某些操作但不返回值的指令。例如，变量绑定 (`let x = 5;`)、函数定义 (`fn foo() {}`) 都是语句。语句通常以分号结尾。
        *   **表达式 (Expressions)**：会计算并产生一个值。例如，`5 + 6` (计算结果为 `11`)、函数调用 (`foo()`)、宏调用 (`println!("hi")`)、用花括号创建的代码块 (`{ let x = 1; x + 1 }`) 都是表达式。
        *   **区别的重要性**：
            1.  **函数返回值**：Rust 函数的返回值是函数体最后一个表达式的值。如果最后一个表达式后面加了分号，它就变成了语句，其值为 `()` (unit type)，这可能导致类型不匹配的编译错误。
                ```rust
                fn get_value() -> i32 {
                    5 // 表达式，返回 5
                }
                fn get_unit() -> () {
                    5; // 语句，返回 ()
                }
                ```
            2.  **赋值和 `let` 绑定**：`let` 绑定本身是语句，不返回值。你不能写 `let x = (let y = 5);`。
            3.  **代码块作为表达式**：`{}` 代码块可以是一个表达式，它的值是块中最后一个表达式的值。这允许进行更灵活的赋值和流程控制，例如：
                ```rust
                let y = {
                    let x = 3;
                    x + 1 // 这个块的值是 4
                }; // y 被赋值为 4
                ```
            4.  **基于表达式的语言特性**：理解这个区别是掌握 Rust 如何工作的关键，因为 Rust 的很多构造（如 `if`、`match`、函数体）都是表达式，这使得代码可以写得更简洁和富有表现力。

现在，我将为本章创建一个示例 Cargo 项目。
